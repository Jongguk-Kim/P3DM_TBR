# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ts.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits.mplot3d import axes3d, Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar


import numpy as np
from scipy.optimize import linprog
from scipy.spatial import ConvexHull

import sys

def IntersectionPointOf2Lines(L1=None, L2=None, xy=23): 
    
    # L1 = [N1, N2], L2=[N3, N4]
    x = int(xy/10); y=int(xy%10)

    x1=L1[0][x]; y1=L1[0][y]
    x2=L1[1][x]; y2=L1[1][y]
    x3=L2[0][x]; y3=L2[0][y]
    x4=L2[1][x]; y4=L2[1][y]

    N = None 

    if  round(x1, 6) == round(x2, 6) and round(x3, 6) == round(x4, 6) and round(x2, 6) == round(x3, 6): 
        print ("All nodes are at the same line [x=%f]"%(x1))
        return N 
    
    if  round(y1, 6) == round(y2, 6) and round(y3, 6) == round(y4, 6) and round(y2, 6) == round(y3, 6): 
        print ("All nodes are at the same line [y=%f]"%(y1))
        return N 

    if  round(x1, 6) == round(x2, 6) and round(y1, 6) == round(y2, 6) : 
        print ("The nodes on 1st Line is at the same position")
        return N 

    if  round(x3, 6) == round(x4, 6) and round(y3, 6) == round(y4, 6) : 
        print ("The nodes on 2nd Line is at the same position")
        return N 


    if round(x1, 6) == round(x2, 6) and round(x3, 6) != round(x4, 6):  
        iX = x1 
        if round(y3, 6) == round(y4, 6): 
            iY = y3 
            # print("c1")
        else: 
            iY = (y4-y3) / (x4-x3) * (iX - x3) + y3 
            # print("c2")
    elif round(x1, 6) != round(x2, 6) and round(x3, 6) == round(x4, 6):  
        iX = x3 
        if round(y1, 6) == round(y2, 6): 
            iY = y1 
            # print("c3")
        else: 
            iY = (y2-y1) / (x2-x1) * (iX - x1) + y1 
            # print("c4")


    elif round(y1, 6) == round(y2, 6) and round(y3, 6) != round(y4, 6): 
        iY = y1 
        if round(x3, 6) == round(x4, 6): 
            iX = x3 
            # print("c5")
        else: 
            iX = (x4-x3) / (y4-y3) * (iY - y3) + x3 
            # print("c6")
    elif round(y1, 6) != round(y2, 6) and round(y3, 6) == round(y4, 6): 
        iY = y3 
        if round(x1, 6) == round(x2, 6): 
            iX = x1 
            # print("c7")
        else: 
            iX = (x2-x1) / (y2-y1) * (iY - y1) + x1 
            # print("c8")

    else: 
        A1 = (y2-y1) / (x2-x1)
        A2 = (y4-y3) / (x4-x3)

        if round(A1, 6) == round(A2, 6): ## parallel 
            return N 

        B1 = A1 * x1 - y1 
        B2 = A2 * x3 - y3 

        iX = (B1-B2) / (A1-A2)
        iY = A1*(iX - x1) + y1 

    N = [0, 0, 0, 0]
    N[x] = iX; N[y]=iY 
    return N 


def PointsInOutPolyhedron(): 

    '''
    Given a set of points that defines a convex hull, uses simplex LP to determine
    whether point lies within hull.
    `hull_points` -- (N, 3) array of points defining the hull
    `pnt` -- point array of shape (3,)
    '''

    #hull_points, pnt

    pnt = np.array([0.5, 0.000001, 0.100])

    # points = np.random.rand(8, 3)

    points = np.array([
        [0, 0, 0],
        [1, 0, 0],
        [1, 1, 0],
        # [0, 1, 0],
        [0, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
        # [0, 1, 1],
    ])

    hull = ConvexHull(points, incremental=True)
    hull_points = hull.points[hull.vertices, :]

    N = hull_points.shape[0]
    c = np.ones(N)
    A_eq = np.concatenate((hull_points, np.ones((N,1))), 1).T   # rows are x, y, z, 1
    b_eq = np.concatenate((pnt, (1,)))


    result = linprog(c, A_eq=A_eq, b_eq=b_eq)
    # if result.success and c.dot(result.x) == 1.:
    #     print ("OutSide")
    #     # return True
    # else: print ("Inside")
    # # return False

    if result.status == 0: print ("Inside")
    else: print("Outside")


    print (result)

    figure = plt.figure()
    ax = Axes3D(figure)
    Xs=[pnt[0]]
    Ys=[pnt[1]]
    Zs=[pnt[2]]
    ax.scatter(Xs, Ys, Zs, c='b', marker='o')
    Xs = points[:,0]
    Ys = points[:,1]
    Zs = points[:,2]
    ax.scatter(Xs, Ys, Zs, c='gray', marker='*')
    plt.show()

# def nextEdge(i, edges): 

def Grouping_Edges(edges): 
    

    starts =[]
    idx =[]
    for i, e in enumerate(edges): 
        ix = np.where(edges[:,1]==e[0])[0]
        idx.append(0)
        if not len(ix): 
            starts.append(i)

    group=[] 

    if len(starts): 
        
        for i in starts: 
            eg =[edges[i]]
            idx[i]= 1
            # print ("START", "[%d, %d, %d, %d],"%(eg[-1][0],eg[-1][1], eg[-1][2], eg[-1][3]))
            ix = np.where(edges[:,0]==eg[-1][1])[0]
            
            cnt = 0
            while 1: 
                cnt +=1
                if cnt > 30: break 
                if len(ix) ==1 : 
                    eg.append(edges[ix[0]])
                    idx[ix[0]]= 1
                    # print ("[%d, %d, %d, %d],"%(eg[-1][0],eg[-1][1], eg[-1][2], eg[-1][3]))
                    ix = np.where(edges[:,0]==eg[-1][1])[0]
                else: 
                    break 
            group.append(eg)

    i = 0 
    while idx[i] : 
        i += 1 
        if len(idx) == i: break 

    if i < len(idx): 
        inext = 0 
        while idx[i] == 0: 
            eg =[edges[i]]
            idx[i]= 1
            # print ("** start", "[%d, %d, %d, %d],"%(eg[-1][0],eg[-1][1], eg[-1][2], eg[-1][3]))
            ix = np.where(edges[:,0]==eg[-1][1])[0]
            cnt = 0
            while 1: 
                cnt +=1
                if cnt > 1000: break 
                if len(ix) ==1 :
                    if eg[0][0] != edges[ix[0]][1]: 
                        eg.append(edges[ix[0]])
                        idx[ix[0]]= 1
                        # print ("*[%d, %d, %d, %d],"%(eg[-1][0],eg[-1][1], eg[-1][2], eg[-1][3]), idx[ix[0]])
                        ix = np.where(edges[:,0]==eg[-1][1])[0]
                        inext = 1 
                    else: 
                        eg.append(edges[ix[0]])
                        
                        idx[ix[0]]= 1
                        # print ("[%d, %d, %d, %d],"%(eg[-1][0],eg[-1][1], eg[-1][2], eg[-1][3]), idx[ix[0]])
                        inext =  0 

                        group.append(eg)

                        i = 0 
                        while idx[i] : 
                            i += 1 
                            if len(idx) == i: break
                else: 
                    i = ix[0]
                    break 
                if inext ==0: 
                    break 
            if i == len(idx) : 
                break 

    return group 

if __name__ == "__main__":
    dele = [[10000344, 10000137,        2, 10001712], [10000382, 10000381,        1, 10001707] ]
    edges = [   [10000381, 10000330,        1, 10001963] ,
                [10000330, 10000329,        1, 10001962] ,
                [10000329, 10000328,        1, 10001708] ,
                [10000328, 10000327,        1, 10001709] ,
                [10000327, 10000346,       1,10001710] ,
                [10000346, 10000345,        1, 10001711] ,
                [10000345, 10000344,        1, 10001712] ,
                
                [10000137, 10000138,        3, 10001712] ,
                [10000138, 10000139,        3, 10001711] ,
                [10000139, 10000140,        3, 10001710] ,
                [10000140, 10000141,        3, 10001709] ,
                [10000141, 10000117,        3, 10001708] ,
                [10000117, 10000118,        3, 10001962] ,
                [10000118, 10000255,        3, 10001706] ,
                [10000255, 10000256,        3, 10001707] ,
                [10000256, 10000383,        4, 10001707] ,
                [10000383, 10000382,        1, 10001707] ,
                

                [10002971, 10002920,        1, 10003917] ,
                [10002920, 10002919,        1, 10003916] ,
                [10002919, 10002918,        1, 10003683] ,
                [10002918, 10002917,        1, 10003684] ,
                [10002917, 10002936,        1, 10003685] ,
                [10002936, 10002935,        1, 10003686] ,
                [10002935, 10002934,        1, 10003687] ,
                [10002934, 10002727,        2, 10003687] ,
                [10002727, 10002728,        3, 10003687] ,
                [10002728, 10002729,        3, 10003686] ,
                [10002729, 10002730,        3, 10003685] ,
                [10002730, 10002731,        3, 10003684] ,
                [10002731, 10002707,        3, 10003683] ,
                [10002707, 10002708,        3, 10003916] ,
                [10002708, 10002845,        3, 10003681] ,
                [10002845, 10002846,        3, 10003682] ,
                [10002846, 10002973,        4, 10003682] ,
                [10002973, 10002972,        1, 10003682]  ,
                [10002972, 10002971,        1, 10003682]
            ]
    edges = np.array(edges)
    edge = Grouping_Edges(edges)
    print (len(edge))
    sys.exit() 

    verifying = 2

    if verifying ==1: 
        N1 = [0, 0, 10, 1]
        N2 = [0, 0, 10, 10]

        N3 = [0, 0, 1, 10]
        N4 = [0, 0, 10, 10]

        L1 =[N1, N2]
        L2 = [N3, N4]


        N=IntersectionPointOf2Lines(L1, L2, xy=23)

        if not isinstance(N, type(None)): 
            plt.scatter(N[2], N[3], c='red', s=10.0)
            
        plt.scatter(N1[2], N1[3], c='black', s=5.0)
        plt.scatter(N2[2], N2[3], c='black', s=5.0)
        plt.scatter(N3[2], N3[3], c='b', s=5.0)
        plt.scatter(N4[2], N4[3], c='b', s=5.0)

        xs=[N1[2], N2[2]]; ys=[N1[3], N2[3]]; 
        plt.plot(xs, ys, color='green')

        xs=[N3[2], N4[2]]; ys=[N3[3], N4[3]]; 
        plt.plot(xs, ys, color='blue')

        plt.axis('equal')
        plt.show()

    if verifying ==2: 
        PointsInOutPolyhedron()