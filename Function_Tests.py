# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ts.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits.mplot3d import axes3d, Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar


import numpy as np
from scipy.optimize import linprog
from scipy.spatial import ConvexHull

def IntersectionPointOf2Lines(L1=None, L2=None, xy=23): 
    
    # L1 = [N1, N2], L2=[N3, N4]
    x = int(xy/10); y=int(xy%10)

    x1=L1[0][x]; y1=L1[0][y]
    x2=L1[1][x]; y2=L1[1][y]
    x3=L2[0][x]; y3=L2[0][y]
    x4=L2[1][x]; y4=L2[1][y]

    N = None 

    if  round(x1, 6) == round(x2, 6) and round(x3, 6) == round(x4, 6) and round(x2, 6) == round(x3, 6): 
        print ("All nodes are at the same line [x=%f]"%(x1))
        return N 
    
    if  round(y1, 6) == round(y2, 6) and round(y3, 6) == round(y4, 6) and round(y2, 6) == round(y3, 6): 
        print ("All nodes are at the same line [y=%f]"%(y1))
        return N 

    if  round(x1, 6) == round(x2, 6) and round(y1, 6) == round(y2, 6) : 
        print ("The nodes on 1st Line is at the same position")
        return N 

    if  round(x3, 6) == round(x4, 6) and round(y3, 6) == round(y4, 6) : 
        print ("The nodes on 2nd Line is at the same position")
        return N 


    if round(x1, 6) == round(x2, 6) and round(x3, 6) != round(x4, 6):  
        iX = x1 
        if round(y3, 6) == round(y4, 6): 
            iY = y3 
            # print("c1")
        else: 
            iY = (y4-y3) / (x4-x3) * (iX - x3) + y3 
            # print("c2")
    elif round(x1, 6) != round(x2, 6) and round(x3, 6) == round(x4, 6):  
        iX = x3 
        if round(y1, 6) == round(y2, 6): 
            iY = y1 
            # print("c3")
        else: 
            iY = (y2-y1) / (x2-x1) * (iX - x1) + y1 
            # print("c4")


    elif round(y1, 6) == round(y2, 6) and round(y3, 6) != round(y4, 6): 
        iY = y1 
        if round(x3, 6) == round(x4, 6): 
            iX = x3 
            # print("c5")
        else: 
            iX = (x4-x3) / (y4-y3) * (iY - y3) + x3 
            # print("c6")
    elif round(y1, 6) != round(y2, 6) and round(y3, 6) == round(y4, 6): 
        iY = y3 
        if round(x1, 6) == round(x2, 6): 
            iX = x1 
            # print("c7")
        else: 
            iX = (x2-x1) / (y2-y1) * (iY - y1) + x1 
            # print("c8")

    else: 
        A1 = (y2-y1) / (x2-x1)
        A2 = (y4-y3) / (x4-x3)

        if round(A1, 6) == round(A2, 6): ## parallel 
            return N 

        B1 = A1 * x1 - y1 
        B2 = A2 * x3 - y3 

        iX = (B1-B2) / (A1-A2)
        iY = A1*(iX - x1) + y1 

    N = [0, 0, 0, 0]
    N[x] = iX; N[y]=iY 
    return N 


def PointsInOutPolyhedron(): 

    '''
    Given a set of points that defines a convex hull, uses simplex LP to determine
    whether point lies within hull.
    `hull_points` -- (N, 3) array of points defining the hull
    `pnt` -- point array of shape (3,)
    '''

    #hull_points, pnt

    pnt = np.array([0.5, 0.000001, 0.100])

    # points = np.random.rand(8, 3)

    points = np.array([
        [0, 0, 0],
        [1, 0, 0],
        [1, 1, 0],
        # [0, 1, 0],
        [0, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
        # [0, 1, 1],
    ])

    hull = ConvexHull(points, incremental=True)
    hull_points = hull.points[hull.vertices, :]

    N = hull_points.shape[0]
    c = np.ones(N)
    A_eq = np.concatenate((hull_points, np.ones((N,1))), 1).T   # rows are x, y, z, 1
    b_eq = np.concatenate((pnt, (1,)))


    result = linprog(c, A_eq=A_eq, b_eq=b_eq)
    # if result.success and c.dot(result.x) == 1.:
    #     print ("OutSide")
    #     # return True
    # else: print ("Inside")
    # # return False

    if result.status == 0: print ("Inside")
    else: print("Outside")


    print (result)

    figure = plt.figure()
    ax = Axes3D(figure)
    Xs=[pnt[0]]
    Ys=[pnt[1]]
    Zs=[pnt[2]]
    ax.scatter(Xs, Ys, Zs, c='b', marker='o')
    Xs = points[:,0]
    Ys = points[:,1]
    Zs = points[:,2]
    ax.scatter(Xs, Ys, Zs, c='gray', marker='*')
    plt.show()



if __name__ == "__main__": 

    verifying = 2

    if verifying ==1: 
        N1 = [0, 0, 10, 1]
        N2 = [0, 0, 10, 10]

        N3 = [0, 0, 1, 10]
        N4 = [0, 0, 10, 10]

        L1 =[N1, N2]
        L2 = [N3, N4]


        N=IntersectionPointOf2Lines(L1, L2, xy=23)

        if not isinstance(N, type(None)): 
            plt.scatter(N[2], N[3], c='red', s=10.0)
            
        plt.scatter(N1[2], N1[3], c='black', s=5.0)
        plt.scatter(N2[2], N2[3], c='black', s=5.0)
        plt.scatter(N3[2], N3[3], c='b', s=5.0)
        plt.scatter(N4[2], N4[3], c='b', s=5.0)

        xs=[N1[2], N2[2]]; ys=[N1[3], N2[3]]; 
        plt.plot(xs, ys, color='green')

        xs=[N3[2], N4[2]]; ys=[N3[3], N4[3]]; 
        plt.plot(xs, ys, color='blue')

        plt.axis('equal')
        plt.show()

    if verifying ==2: 
        PointsInOutPolyhedron()